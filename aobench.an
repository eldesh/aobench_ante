
type Vec = x: float, y: float, z: float
type Triple a = first: a, second: a, third: a
type Sphere = center: Vec, radius: float
type Plane = p: Vec, n: Vec
type Ray = org: Vec, dir: Vec
type Isect = t: float, p: Vec, n: Vec , hit: bool


width: usz = 256
height: usz = 256
nsubsamples = 2
nao_samples = 8

impl Cast float string with
  cast f =
    conv f =
      if f < 0.0 then
        "-${conv (0.0-f)}"
      else
        uint: u64 = cast f
        f2 = f - cast uint
        // Show up to 5 decimal places
        fr: u64 = cast (f2 * 10_000.0)
        "${uint}.${fr}"
    conv f


// impl Print (a, b) given Cast a string, Cast b string with
//   printne t = match t | (a, b) -> printne "(${a},${b})"

impl Print (a, b, c) given Cast a string, Cast b string, Cast c string with
  printne t = match t | (a, b, c) -> printne "(${a},${b},${c})"


init () : Triple Sphere, Plane =
  ss    = Triple (Sphere (Vec -2.0 0.0 -3.5) 0.5)
                 (Sphere (Vec -0.5 0.0 -3.0) 0.5)
                 (Sphere (Vec  1.0 0.0 -2.2) 0.5)
  plane = Plane  (Vec 0.0 -0.5 0.0)
                 (Vec 0.0  1.0 0.0)
  ss, plane


// inner product
iprod (v0:Vec) (v1:Vec) : float =
  (v0.x * v1.x) + (v0.y * v1.y) + (v0.z * v1.z)


abs v : float =
  if 0.0 <= v then v
  else 0.0 - v


sqrt (v:float) : float =
  go x m =
    // print x
    if abs (x - m) < 0.0000000000001 then x
    else
      go ((x + (v / x)) / 2.0) x
  go (v / 2.0) 0.0

// x = (sqrtr 123.0)
// print "${x} * ${x} = ${x * x}"


vnormalize (c:Vec) : Vec =
  length = sqrt (iprod c c)
  // print "length: ${length}"
  if abs length > 0.00000000001
  then Vec (c.x / length) (c.y / length) (c.z / length)
  else c


negate (n:float) : float =
  0.0 - n


ray_sphere_intersect isect (r:Ray) (s:Sphere) =
  rs = Vec (r.org.x - s.center.x)
           (r.org.y - s.center.y)
           (r.org.z - s.center.z)
  b = iprod rs r.dir
  c = iprod rs rs - s.radius * s.radius
  d = b * b - c
  if d > 0.0
  then
    t = negate b - sqrt d
    if t > 0.0 and t < isect.t
    then
      p = Vec (r.org.x + r.dir.x * t)
              (r.org.y + r.dir.y * t)
              (r.org.z + r.dir.z * t)
      n = Vec (p.x - s.center.x)
              (p.y - s.center.y)
              (p.z - s.center.z)
      Isect t p (vnormalize n) true
    else
      isect
  else
    isect


render img (w:usz) (h:usz) nsubsamples (spheres:Triple Sphere) plane : unit =
  fimg = calloc (w * h * 3) 8
  iter (Range 0 h) fn (y:usz) ->
    iter (Range 0 w) fn (x:usz) ->
      iter (Range 0 nsubsamples) fn (v:usz) ->
        iter (Range 0 nsubsamples) fn (u:usz) ->
          zero = Vec 0.0 0.0 0.0
          px   =       (cast x + (cast u / cast nsubsamples) - (cast w/2.0)) / (cast w/2.0)
          py   = negate(cast y + (cast v / cast nsubsamples) - (cast h/2.0)) / (cast h/2.0)
          ray  = Ray zero (vnormalize (Vec px py -1.0))

          isect = Isect 100000000000000000.0 zero zero false
          isect2 = ray_sphere_intersect isect ray spheres.first


print "init_scene..."
spheres, plane = init ()
print "rendering..."
img = calloc (width * height * 3) 1
render img width height nsubsamples spheres plane
free img

