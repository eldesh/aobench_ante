import Random.rand
import Random.randReal

type Vec = x: float, y: float, z: float
type Triple a = first: a, second: a, third: a
type Sphere = center: Vec, radius: float
type Plane = p: Vec, n: Vec
type Ray = org: Vec, dir: Vec
type Isect = t: float, p: Vec, n: Vec , hit: bool


width: usz = 256
height: usz = 256
nsubsamples = 2
nao_samples = 8

impl Cast float string with
  cast f =
    conv f =
      if f < 0.0 then
        "-${conv (0.0-f)}"
      else
        uint: u64 = cast f
        f2 = f - cast uint
        // Show up to 5 decimal places
        fr: u64 = cast (f2 * 10_000.0)
        "${uint}.${fr}"
    conv f


// impl Print (a, b) given Cast a string, Cast b string with
//   printne t = match t | (a, b) -> printne "(${a},${b})"

impl Print (a, b, c) given Cast a string, Cast b string, Cast c string with
  printne t = match t | (a, b, c) -> printne "(${a},${b},${c})"


init () : Triple Sphere, Plane =
  ss    = Triple (Sphere (Vec -2.0 0.0 -3.5) 0.5)
                 (Sphere (Vec -0.5 0.0 -3.0) 0.5)
                 (Sphere (Vec  1.0 0.0 -2.2) 0.5)
  plane = Plane  (Vec 0.0 -0.5 0.0)
                 (Vec 0.0  1.0 0.0)
  ss, plane


// inner product
iprod (v0:Vec) (v1:Vec) : float =
  (v0.x * v1.x) + (v0.y * v1.y) + (v0.z * v1.z)


abs v : float =
  if 0.0 <= v then v
  else 0.0 - v


sqrt (v:float) : float =
  go x m =
    // print x
    if abs (x - m) < 0.0000000000001 then x
    else
      go ((x + (v / x)) / 2.0) x
  go (v / 2.0) 0.0

// x = (sqrtr 123.0)
// print "${x} * ${x} = ${x * x}"


vnormalize (c:Vec) : Vec =
  length = sqrt (iprod c c)
  // print "length: ${length}"
  if abs length > 0.00000000001
  then Vec (c.x / length) (c.y / length) (c.z / length)
  else c

vcross (v0:Vec) (v1:Vec) : Vec =
  Vec (v0.y * v1.z - v0.z * v1.y)
      (v0.z * v1.x - v0.x * v1.z)
      (v0.x * v1.y - v0.y * v1.x)


negate (n:float) : float =
  0.0 - n


ray_sphere_intersect isect (r:Ray) (s:Sphere) =
  rs = Vec (r.org.x - s.center.x)
           (r.org.y - s.center.y)
           (r.org.z - s.center.z)
  b = iprod rs r.dir
  c = iprod rs rs - s.radius * s.radius
  d = b * b - c
  if d > 0.0
  then
    t = negate b - sqrt d
    if t > 0.0 and t < isect.t
    then
      p = Vec (r.org.x + r.dir.x * t)
              (r.org.y + r.dir.y * t)
              (r.org.z + r.dir.z * t)
      n = Vec (p.x - s.center.x)
              (p.y - s.center.y)
              (p.z - s.center.z)
      Isect t p (vnormalize n) true
    else
      isect
  else
    isect

ray_plane_intersect isect (r:Ray) (p:Plane) =
  d = negate(iprod p.p p.n)
  v = iprod r.dir p.n
  if abs v < 0.00000000000000001
  then isect
  else
    t = negate ((iprod r.org p.n) + d) / v
    if t > 0.0 and t < isect.t
    then
      Isect t
            (Vec (r.org.x + r.dir.x * t)
                 (r.org.y + r.dir.y * t)
                 (r.org.z + r.dir.z * t))
            p.n
            true
    else
      isect


orthoBasis (n: Vec) : (Vec, Vec, Vec) =
  basis2 = n
  basis1 = if n.x < 0.6 and n.x > -0.6 then
             Vec 1.0 0.0 0.0
           else if n.y < 0.6 and n.y > -0.6 then
             Vec 0.0 1.0 0.0
           else if n.z < 0.6 and n.z > -0.6 then
             Vec 0.0 0.0 1.0
           else
             Vec 1.0 0.0 0.0
  basis0 = vnormalize (vcross basis1 basis2)
  basis1 = vnormalize (vcross basis2 basis0)
  basis0, basis1, basis2


drand48 () : float =
  _ = rand 48271 1073741823
  randReal 1.0


ambient_occlusion (isect:Isect) (spheres:Triple Sphere) plane =
  ntheta: usz = nao_samples
  nphi   = nao_samples
  eps: float = 0.0001
  p      = Vec (isect.p.x + eps * isect.n.x)
               (isect.p.y + eps * isect.n.y)
               (isect.p.z + eps * isect.n.z)
  basis0, basis1, basis2 = orthoBasis (isect.n)
  occlusion = mut 0.0

  iter (Range 0 ntheta) fn (j:usz) -> ()
  //   iter (Range 0 nphi) fn i ->
  //     // theta = sqrt(drand48())
  // for {begin=0, limit=ntheta, step=succ} (fn j=>
  //   for {begin=0, limit=nphi, step=succ} (fn i=>
  //     let
  //       val theta = Math.sqrt(drand48())
  //       val phi   = 2.0 * Math.pi * drand48()
  //       val (x,y,z) = ( (Math.cos phi) * theta
  //                     , (Math.sin phi) * theta
  //                     , Math.sqrt (1.0 - theta * theta))
  //       val rx = x * (#x basis0) + y * (#x basis1) + z * (#x basis2)
  //       val ry = x * (#y basis0) + y * (#y basis1) + z * (#y basis2)
  //       val rz = x * (#z basis0) + y * (#z basis1) + z * (#z basis2)
  //       val zero = { x=0.0, y=0.0, z=0.0 }
  //       val ray = { org= p, dir= { x= rx, y= ry, z= rz } }
  //       val occIsect = { t= 1.0e17, p=zero, n=zero, hit= false }
  //       val occIsect = ray_sphere_intersect occIsect ray (#1 spheres)
  //       val occIsect = ray_sphere_intersect occIsect ray (#2 spheres)
  //       val occIsect = ray_sphere_intersect occIsect ray (#3 spheres)
  //       val occIsect = ray_plane_intersect occIsect ray plane
  //     in
  //       occlusion := !occlusion + (if #hit occIsect then 1.0 else 0.0)
  //     end
  //   ));
  // let val occlusion = (real (ntheta * nphi) - !occlusion)
  //                   / real (ntheta * nphi)
  // in
  //   { x=occlusion, y=occlusion, z=occlusion }
  // end


render img (w:usz) (h:usz) nsubsamples (spheres:Triple Sphere) plane : unit =
  fimg = calloc (w * h * 3) 8
  iter (Range 0 h) fn (y:usz) ->
    iter (Range 0 w) fn (x:usz) ->
      iter (Range 0 nsubsamples) fn (v:usz) ->
        iter (Range 0 nsubsamples) fn (u:usz) ->
          zero = Vec 0.0 0.0 0.0
          px   =       (cast x + (cast u / cast nsubsamples) - (cast w/2.0)) / (cast w/2.0)
          py   = negate(cast y + (cast v / cast nsubsamples) - (cast h/2.0)) / (cast h/2.0)
          ray  = Ray zero (vnormalize (Vec px py -1.0))

          isect1 = Isect 100000000000000000.0 zero zero false
          isect2 = ray_sphere_intersect isect1 ray spheres.first
          isect3 = ray_sphere_intersect isect2 ray spheres.second
          isect4 = ray_sphere_intersect isect3 ray spheres.third
          isect5 = ray_plane_intersect  isect4 ray plane

          if isect5.hit
          then
            col = ambient_occlusion isect5 spheres plane
            ()
          else
            ()


print "init_scene..."
spheres, plane = init ()
print "rendering..."
img = calloc (width * height * 3) 1
render img width height nsubsamples spheres plane
free img

